# 5주차

## FLP 정리

### 결정론적 알고리즘

입력값과 초기 상태가 같다면, 언제 실행하든 항상 똑같은 과정을 거쳐 똑같은 결과를 내놓아야 함. 무작위성이 개입되지 않음

### 비동기 시스템

메시지 전송이나 프로세스 처리에 걸리는 시간에 상한선이 없음. 즉, 응답이 늦게 오는 것이 시스템이 느린 것인지, 프로세스가 고장 난 것인지 구분할 수 없음              

[https://timroughgarden.github.io/fob21/l/l4-5.pdf](https://timroughgarden.github.io/fob21/l/l4-5.pdf) 

### FLP 정리

**비동기 시스템**에서 단 하나의 **프로세스라도 고장** 날 수 있는 상황이라면, 확실한 합의를 이룰 수 있는 **결정론적 알고리즘**이 존재할 수 없다

예시

- 시스템이 합의를 하려는데, 컴퓨터 한 대(A)로부터 응답이 오지 않는 상황
- **비동기 시스템**이므로, A가 고장이 났는지 시스템이 느린 것인지 구분할 수 없음

⇒ 결정론적 알고리즘을 어떤 방식으로 짜더라도, 비동기 환경에서는 실패하는 시나리오가 존재함

1.  ****응답이 올 때 까지 기다리기
- 만약 A가 진짜 고장 난 거였다면 영원히 기다리게 됨,  0또는 1의 합의값을 결정하지 못하고 영원히 2가 상태 → Liveness 위반
1. 기다리다 응답이 없으면 진행
- 만약 A가 고장 난 게 아니라 그냥 아주 느린 거였다면? A는 나중에 살아나서 혼자 다른 결정을 내리거나, 전체 합의가 깨짐 → Safety 위반

결국, 고장과 지연을 구별할 수 없는 환경에서는 어떤 결정론적 규칙을 가져와도 Safety(일관성)와 Liveness(응답성)를 동시에 100% 만족시키는 것은 수학적으로 불가능함

### 현실에서의 타협 - Kubernetes의 etcd (Liveness 포기)

etcd: 쿠버네티스 클러스터의 모든 상태 데이터를 저장하는 분산 데이터베이스 

- Leader: 모든 데이터 쓰기 요청을 받고 Follower에게 받아적으라고 명령하는 역할
- Follower: 리더가 시키는 대로 적은 후 리더에게 보고하는 역할

데이터 저장 과정

1. Leader가 사용자에게 데이터 쓰기 요청을 받음
2. Leader는 모든 Follower에게 저장 요청하는 메시지를 보냄
3. Follower들은 노트를 적고 Leader에게 Ack 보냄
4. Leader는 본인 포함 정족수가 넘는 참여자가 적었는지 Ack을 셈 
- 정족수가 넘었다? ->  Commit 후 사용자에게 성공 응답 보냄
- 정족수가 안 됐다? -> 무한 대기하거나 실패 처리
    
    ⇒  Liveness 포기하는 대신 Safety 위반을 막아 서버간 데이터 불일치를 방지