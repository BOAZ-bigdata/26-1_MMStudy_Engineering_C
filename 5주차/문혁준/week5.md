 분산 시스템에서는 합의도 중요하지만, 네트워크도 큰 영향을 미친다.

![](https://velog.velcdn.com/images/likell1/post/6b7edbfd-9fd3-4d86-9d73-1e785c8efd73/image.png)


# CAP 정리

> **📌 CAP 정리란?** 
분산 시스템이 **동시에 모두 만족할 수 없는 3가지 속성**을 정의한 이론이다.
> 

여기서 말하는 3가지 속성은 **강한 일관성(Consistency), 가용성(Availability), 단절 내성(Partition Tolerance) 를 말한다.**

👉🏻 즉, CAP 정리를 다시 말하면, 이렇게 풀어 쓸 수 있는데

> 분산 시스템은 **C(Consistency), A(Availability), P(Partition Tolerance)**
> 
> 
> 이 세 가지 중 **최대 두 가지만 보장할 수 있다**
> 

> **즉 쉽게 말해서, 네트워크 분리가 발생하면(P)**
> 
> 
> **Consistency 또는 Availability 중 하나를 포기해야 한다**
> 

이게 무엇을 의미하는지 자세히 알아보자!

---

## CAP의 구성요소 3가지

### **C — Consistency (일관성)**

> **모든 노드가 같은 시점에 같은 데이터를 보아야 한다.**
> 
- 언제든지 어떤 사용자가 데이터를 읽어도 **완전히 동일하고 일관된 정보를 표시해야 함**
- **항상 최신의 값**을 반환해야 함

> 📌 예시:
> 
> - A 서버에 값을 쓰고, 바로 B 서버에서 읽었을 때
> - 👉🏻 **반드시 방금 쓴 값이 보여야 함**

---

### A — Availability (가용성)

> **모든 요청은 실패하지 않고 응답을 받아야 한다.**
> 
- 일부 노드가 다운되어도 시스템은 **항상 응답해야 함**
- 즉시는 아니더라도, 결국 언젠가는 일관성을 가지게 된다는 **궁극적 일관성**의 개념

> 📌 예시:
> 
> - 서버 4대 중 1대가 죽어도
> - 읽기/쓰기 요청은 계속 처리됨
> - ⚠️ 단, 이 응답이 **최신 데이터라는 보장은 없다** (궁극적 일관성)

---

### P — Partition Tolerance (단절 내성 / 네트워크 분리)

> **네트워크 장애가 발생해도 시스템이 동작해야 한다.**
> 
- 노드 간 네트워크가 끊어지는 상황
- 네트워크가 끊어져도 프로세스들이 자율적으로 각자의 작업을 수행함

> 📌 예시:
> 
> - 데이터센터 A ↔ B 사이 네트워크 단절
> - 네트워크는 끊어져도 각 시스템은 계속 동작

---

따라서 시스템 운영자는 **CAP 3가지를 모두 만족시킬 수 없다**는 것을 알고

애플리케이션의 특성에 따라 **CP vs AP 중 적절한 정책을 수립해야 한다.**

> **현실 세계에서는 네트워크 지연, 패킷 유실, 일시적 단절 등의 문제가 무조건 발생하기 때문에 P는 무조건 선택해야 한다!**
> 

---

## CAP 조합 3가지

![](https://velog.velcdn.com/images/likell1/post/a43b720d-af5b-4b63-af45-45e42de0b07b/image.png)


### 1. CP 시스템 (Consistency + Partition Tolerance)

> **응답이 없거나 느리더라도 절대 틀리면 안됨**
> 

**특징**

- **데이터의 정합성 보장**
- 네트워크 분리(P) 발생 시 → **일부 요청을 거부 (가용성 포기)**
- 주로 은행 계좌, 송금, 결제 트랜잭션에서 사용

**대표 시스템**

- HBase
- Mongo DB
- redis

---

### 2. AP 시스템 (Availability + Partition Tolerance)

> **데이터가 조금 틀리더라도 무조건 응답**
> 

**특징**

- 네트워크 분리(P) 발생 시에도 → **무조건 응답**
- 대신 데이터 불일치 허용 / 나중에 동기화

**대표 시스템**

- Cassandra
- AWS DynamoDB

---

### 3. CA 시스템 (Consistency + Availability)

> 이론적으로만 가능
> 

**특징**

- 네트워크 분할이 없다는 전제
- 즉, 분산 시스템이 아닌 단일 시스템

---

즉, CAP 정리는 네트워크 Partition이 발생하는 것이 기본적인 사항이며,

Partition이 발생했을 때, 시스템 설계자가 장애 상황에서의 선택을 어떻게 해야하는지 잘 정리해주었다.

**❌ 하지만, CAP를 현실에서 그대로 적용하기에는 한계가 있다.**

---
### CAP 정리의 한계

**1️⃣ 우선 첫 번째,**

> CAP 정리에 따르면, 분산 시스템은 네트워크 Partition이 발생할 수 있다는 전제 하에서,
Consistency(C)와 Availability(A)를 동시에 보장할 수 없다.
> 

**하지만, 현실의 분산 시스템에서는 네트워크가 항상 분리되어 있는 것은 아니며, 대부분의 시간은 Partition이 없는 정상 상태로 동작한다.**

> 만약, 네트워크 Partition이 없는 정상 상태일 때는 어떤 트레이드오프를 선택해야 할까?
> 

**⚠️ 정상 상태일 때에도, CP vs AP 를 선택하는 것은 논리에 어긋난다.**

---

**2️⃣ 두 번째,** 

> 현실에서는 일관성(C)의 종류와 강도가 매우 다양하다.
> 

다만, **CAP 정리는 일관성(C)을 강한 일관성만을 기준으로 판단하기 때문에, 현실의 모든 문제를 세분화하기 어렵다.**

---

**3️⃣ 세 번째,**

> CAP 정리는 Latency(지연)을 충분히 설명하지 못해서, 시스템 간 비교가 어렵다.
> 

**CAP 정리는 시스템을 이분법적으로 구분하기 때문에, 같은 CP/AP 내에서도 존재하는 다양한 상황을 비교하기 어렵다.**

즉, 실제 시스템에서는 지연(Latency), 트랜잭션 유형, 사용자 경험과 같은 요소들이 일관성 선택에 큰 영향을 미치지만, CAP 정리는 이를 직접적으로 다루지 않는다.

---

즉, CAP 정리는 네트워크 Partition 발생 시의 트레이드오프를 설명하는 데에는 유용하지만,

**⚠️ 정상 상태에서의 지연과 일관성 선택, 그리고 다양한 일관성 수준과 성능 특성을 충분히 설명하지 못한다.**

> **🔥 이러한 CAP의 한계를 보완하기 위해 등장한 것이 PACELC 정리이다.**
> 

---

# PACELC

![](https://velog.velcdn.com/images/likell1/post/f1a4a247-fded-4871-ba21-a6877a9af99f/image.png)


> **PACELC**란, 
**네트워크 분리(Partition) 시에만, 트레이드오프를 고려하는 것이 아니라**
**정상 상태(Else) 에서도, Consistency와 Latency 사이의 지속적인 트레이드 오프를 고려**함
> 

> 👉🏻 즉, 분산 시스템에서는 장애 상황이 아닌 **“정상 상태”에서도 트레이드오프가 존재한다.**
> 

---

#### PACELC 정리에 따르면, 시스템은 총 4가지가 가능함.

- **PA / EL** → 장애 상황에서 **가용성** 우선 / 정상 상황에서도 **빠른 응답** 우선
- **PA / EC** → 장애 상황에서 **가용성** 우선 / 정상 상황에서는 **정합성** 우선
- **PC / EL** → 장애 상황에서 **일관성** 우선 / 정상 상황에서는 **빠른 응답** 우선
- **PC / EC** → 장애 상황에서 **일관성** 우선 / 정상 상황에서도 **정합성** 우선


#### 표로 간단히 정리하면, 이렇다.

| 유형 | Partition 발생 시 | 평상시(Else) |
| --- | --- | --- |
| **PA/EL** | Availability | Low Latency |
| **PA/EC** | Availability | Consistency |
| **PC/EL** | Consistency | Low Latency |
| **PC/EC** | Consistency | Consistency |

> **즉, PACELC 정리는 시스템을 이분법적으로 나누는 것이 아닌, 시스템의 설계 상황을 파악할 수 있다.**
> 

---

### Partition 발생 시

> **A ↔ C 선택**
> 
- AP: 가용성 우선
- CP: 일관성 우선

CAP 정리와 동일

---

### Partition 없을 때 (Else)

> **L ↔ C 선택**
> 
- Latency: 빠른 응답, 로컬 처리
- Consistency: 글로벌 동기화, 최신 데이터 보장


🔗 **Reference**
[PACELC](https://www.scylladb.com/glossary/pacelc-theorem/)
[CAP정리](https://minseoky.me/Etc/CAPtheorem/)

---
![](https://velog.velcdn.com/images/likell1/post/e38d97b8-76c9-49af-bc96-87cc4e8f44ec/image.png)


# FLP 정리

> **_FLP 불가능성 정리 (Fischer–Lynch–Paterson, 1985)_**
> 

> **📌 비동기 분산 시스템에서, 단 하나의 노드라도 고장날 수 있는 상황이라면, 모든 경우에 대해 합의(Consensus)를 보장하는 알고리즘은 존재하지 않는다.**
> 

여기서

- **비동기(Asynchronous) 시스템**
    - 작업 완료를 기다리지 않고 다음 작업을 바로 처리하는 시스템
- **하나의 노드라도 고장날 수 있는 상황**
    - 어느 순간 갑자기 Crash 될 수 있음
- **결정적 알고리즘**
    - 동일 입력 · 상황이면 항상 같은 동작을 하는 알고리즘

> 즉, FLP 정리에 따르면, 비동기 + 장애가 발생할 수 있는 환경에서는 항상 종료까지 보장하는 **합의**가 불가능하다.
> 

❓왜 그럴까?

우선 먼저, **합의(Consensus)**에 대해 먼저 생각해보자.

---

## 합의(Consensus)

> **네트워크에 흩어져 있는 여러 노드(컴퓨터)들이 시스템의 단일한 상태나 특정 값에 대해 모두 동의하는 과정**
> 

즉, 분산 시스템에서는 모든 노드가 합의해야 트랜잭션이 발생할 수 있다.

❓ 그럼 합의는 어떻게 해야 이루어질 수 있을까?

**→ 다음의 합의 조건을 만족해야한다.**

| 조건 | 설명 |
| --- | --- |
| **종결 (Termination)** | 장애가 없는 모든 노드들은 궁극적으로 어떤 값을 결정한다. |
| **동의 (Agreement)** | 모든 정상 노드는 동일한 값을 결정해야 한다. |
| **타당성 (Validity)** | 결정된 어떤 값은 반드시 누군가 제안한 값이어야 한다. |

> **이 세 가지 조건을 모두 만족해야 합의가 가능하다.**
> 

---

여기서 한 가지 아이디어를 생각해보자,

N개의 분산 장치가 존재하고, 이들 장치가 서로 메시지를 주고 받으며 결정을 내린다.

이 중 하나의 장치는 장애로 인해 무응답하거나 메시지 지연이 발생할 수 있다고 가정하자.

*이러한 상황에서 **정상 상태인 N-1개의 분산 장치가 궁극적으로 합의할 수 있는 결정적 알고리즘이 있을까?***

❌ 정답은 존재하지 않는다.

이것이 FLP 정리 핵심 아이디어이다.

❓ 왜 그럴까?

---

## FLP 불가능성 정리의 이유

FLP 정리에 따르면, 합의할 수 있는 결정적 알고리즘이 존재하지 않는 이유 중 하나는 **장애**이다.

왜냐하면, **장애를 일으키는 프로세스가 결정을 불확실하게 만들기 때문이다.**

- 합의 과정에 참여하는 노드들의 초기 상태: ‘2가 상태(bi-valent)’로 정의
    - **2가 상태(bi-valent):** 두 가지 결정(0/1)이 모두 일어날 수 있는 상태
    - → FLP 정리에 따르면 분산 환경에서는 노드들이 어떤 값으로 합의할지 확신할 수 없다.

> **하나의 장애를 일으키는 노드가 있는 경우, 나머지 노드들이 종결, 동의, 타당성을 확신할 수 없다는 것**
> 
> 
> **즉, 합의(Consensus)의 조건에 위배된다.**

- ***Why?***
    - 느린 노드와 고장난 노드를 **구분할 방법이 없음**
    - 즉, 이 노드가 느린건지?, 아니면 크래시(Crash)한 건지 알 수가 없음
- ***If 만약***
    - **느린 것** → 기다리지 않고 먼저 결정 → 나중에 도착한 메세지와 **모순 → 동의 ❌**
    - **죽은 것** → 기다리면 **영원히 안 끝남 → 종결 ❌**
    
    (아무리 결정적인 알고리즘이더라도 이러한 딜레마를 풀 방법 존재 X)
    

## FLP 정리 결론

> FLP 정리는 비동기 + 장애 가능 환경에서는
> 
> 
> **합의의 안전성과 종료성을 동시에 항상 보장하는 것이 원천적으로 불가능함을 보여준다.**
> 
> → Safety와 Liveness를 **항상 동시에** 만족할 수 없다
> 

그렇다면, 둘 중 Safety(합의 일관성)을 보장하는 합의 방법은 없을까?

---

# 정족수(Quorum) 합의

> 전체 노드 중 ‘과반수’의 동의를 얻었을 때만, 결정을 유효하다고 인정하는 방식
> 

정족수 합의는 FLP 환경에서 **안정성을 보장하는 합의**이다.

전체 노드들 중에서, 응답하는 노드가 과반수(quorum) 이상이면, 응답하는 노드끼리 합의할 수 있다.

> 모든 노드를 기다리다 영원히 끝나지 않는 것보다는, **과반수를 통해 서로 다른 값이 결정되지 않게 안정성이라도 보장하자는 것.**
> 

### 예시 상황

노드: A B C D E

정족수: 3

상황

- A, B, C → 값 X에 합의
- D → 무응답
- E → 값 Y

> A, B, C로부터 과반수의 응답을 확보한 경우, 값 X를 결정하더라도 합의의 안전성은 유지
> 

> 다만, FLP 정리에서는 이러한 과반수 확보가 **항상 가능하다는 보장은 없다.**
>