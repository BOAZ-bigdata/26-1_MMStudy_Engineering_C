# 벡터 시계

## **1) 램포트 시계 탄생 배경**

분산 시스템에서는 프로세스가 여러 대라서 “어떤 일이 먼저 일어났는지”가 애매해진다.

그래서 “정확한 실제 시간(몇 시 몇 분 몇 초)”을 맞추는 게 아니라, 
이벤트들 사이의 순서(선후 관계)를 정하는 게 중요하다고 말한다.

그래서 나온 것이 **램포트 시계**

- **램포트 시계**란?
    
    각 프로세스가 숫자 하나(논리적 시계 값)를 관리하면서,
    V
    이벤트들에 논리적 순서(선후 관계)를 붙이는 규칙(기법)
    



## **2) 램포트 시계 동작**

각 프로세스는 자기 논리적 시계 값 C를 가진다.

- **내부에서 이벤트가 발생하면** C를 1 증가
- **메시지를 보낼 때도** C를 1 증가시키고, 그 값을 메시지에 실어서 보냄
- **메시지를 받을 때는**
    
    “내 C 값” 과 “메시지에 실려 온 C 값” 중 큰 값으로 맞춘 뒤 1 증가
    

이 규칙 덕분에 메시지를 주고 받아 연결되는 이벤트들은
순서가 꼬이지 않게 정리된다.



## **3-1) 램포트 시계의 한계**

### **:** `순서`**는 정하지만 `관계`는 모른다**

> 램포트 시계는 모든 이벤트를 일단 순서대로 줄 세울 수는 있지만,
그 순서가 **정말 의미 있는 선후 관계**인지까지는 확실히 알기 어렵다.
> 

### **왜 그럴까?**

분산 시스템에는 서로 영향을 준 사건도 있고, 독립적인 사건도 있다.

- 설명
    - 서로 영향을 준 사건: 메시지로 이어져서 **선후 관계가 분명함**
    - 독립적인 사건: 따로 발생했기 때문에 ‘누가 먼저’가 의미 없을 수도 있음
        - 독립 사건 = 서로 영향 없는 사건(동시로 볼 수 있음)

그런데 램포트 시계는 모든 사건에 번호를 붙이다 보니,

독립적인 사건도 겉으로는 앞뒤가 있는 것처럼 보일 수 있다.

- 정확히 말하자면
    - **C(a) < C(b)라고 해서 a → b가 성립하는 것은 아니다**
    - 하지만 **a → b이면 반드시 C(a) < C(b)** 는 성립한다

정리하면

: **램포트 시계는 순서는 만들 수 있지만, 독립 사건인지까지는 구분하기 어렵다.**



## **3-2) 램포트 한계 예시**

### **상황: 서버 A와 서버 B가 있고, 이벤트가 각각 발생**

<aside>
☝

- 서버 A에서 이벤트 A1 발생
- 서버 B에서 이벤트 B1 발생
    
    (중요: A1과 B1은 서로 메시지를 주고받은 적이 없음 → 즉, 연결된 관계가 없음)
    
</aside>

현실적으로, 이 둘은 **서로 독립 사건**일 가능성이 크다.

근데 램포트 시계에서는 시계 값이 다를 것이다.

예를 들면:

- 서버 A는 C=5인 상태에서 A1 발생 → A1의 값이 6
- 서버 B는 C=20인 상태에서 B1 발생 → B1의 값이 21

이제 숫자만 보면:

- A1(6) < B1(21)이니까 “A1이 먼저”라고 말할 수는 있다.

근데 여기서 중요한 건:

- **A1이 숫자가 더 작다고 해서, B1이 A1 때문에 일어났다는 뜻은 아니다.**
    
    → 둘은 메시지를 주고 받지 않았으니, 연결된 사건이 아니다. → 독립 사건
    
- 실제로 B1이 늦게 발생했다는 뜻이 아니라,
단순히 B의 원래 시계 값이 컸기 때문에 그렇게 보일 수 있다.

즉, 램포트 시계 값 비교로는

**선후 관계가 의미 있는지, 독립사건인지** 까지 확신하기 어렵다.

→ 그래서 `독립 사건`을 구분할 수 있는 `벡터 시계`가 나왔다.



## **4) 벡터 시계는 뭐가 다를까?**

### **: `숫자 1개`가 아니라 `벡터 형식`**

벡터 시계는 각 서버가 숫자 1개만 들고 있지 않고,

전체 서버 개수만큼 칸이 있는 벡터를 들고 있다.

예를 들어 서버가 A, B, C 세 대면 벡터는

: [A칸, B칸, C칸]

- 여기서 각 칸의 의미는 **이벤트 개수 (서버 번호 X)**

벡터 시계에서 [a, b, c] 각 칸의 뜻은 이렇다:

- a: “A에서 일어난 이벤트를 **a개까지** 나는 알고 있다”
- b: “B에서 일어난 이벤트를 **b개까지** 나는 알고 있다”
- c: “C에서 일어난 이벤트를 **c개까지** 나는 알고 있다”

여기서 알고 있다는 건:

- 내가 직접 처리했거나
- 메시지로 전달받아서 반영했거나
    
    해서 ***내 서버의 상태에 반영됐음***을 뜻한다.
    
- 예시: **A가 현재 갖고 있는 벡터가** [0,1,2]라면
    
    **A**는 
    
    - **A**에서 일어난 이벤트를 아직 0번까지 반영했고(반영된 게 없다),
    - **B**에서 일어난 이벤트는 1번까지 반영했고,
    - **C**에서 일어난 이벤트는 2번까지 반영했다.

→ 즉, 벡터 [a,b,c]에서 각 칸은 **A/B/C의 이벤트를 내가 어디까지 반영했는지를 나타내는 카운트다.**



## **5-1) 벡터 시계 동작**

각 서버는 자기 벡터를 유지한다.

1. **내 이벤트 발생**: 내 칸만 +1
2. **메시지 전송**: 내 칸 +1 하고, 자기 벡터 전체를 메시지에 함께 실어 보냄
3. **메시지 수신**:
    - 내 벡터와 메시지 벡터를 칸별로 비교해서 더 큰 값으로 내 벡터 갱신(최댓값)
    - 그리고 받은 것도 이벤트니까 내 칸 +1



## **5-2) 예시 2개로 벡터 시계 알아보기**

### **예시 1) 벡터 시계로 `독립 사건` 잡아내기**

<aside>

서버 A, B 두 대라고 하고, 시작 벡터는 둘 다 [0,0].

- A에서 이벤트 A1 발생 → **A는 [1,0]**
- B에서 이벤트 B1 발생 → **B는 [0,1]**
</aside>

이 두 벡터를 비교해보면:

- A 벡터 [1,0]이 B 벡터 [0,1]보다 **모든 칸에서 작거나 같지 않음**
- 반대로 B 입장인 [0,1]도 [1,0]보다 **모든 칸에서 작거나 같지 않음**

즉, **서로 비교가 안 됨.**

→ 이 경우를 **`독립적으로 일어난 사건`**으로 본다.

→ 이걸 **램포트 시계**는 확실하게 잡아내기 어려웠고, **벡터 시계**는 잡아낸다.

```sql
A1: [1,0], B1: [0,1] → 서로 비교 불가 → 독립 사건
```

### **예시 2) 벡터 시계로 `선후 관계` 잡아내기**

<aside>

이벤트 A1이 발생한 뒤에 A가 B에게 메시지를 보냈다.

1. A에서 이벤트 A1 발생: **A 벡터 [1,0]**
2. A가 메시지 보냄(벡터 포함해서): **A 벡터 [2,0]** (보내기도 이벤트니까 +1)
3. B가 메시지를 받음:
    
    B는 자기 벡터 [0,0]과 받은 벡터 [2,0]을 최댓값으로 정리해 **[2,0]**
    
    그리고 메시지 수신 이벤트로 **B칸 +1 → [2,1]**
    
</aside>

이 상태에서는:

- A에서 메시지 **보낸 사건([2,0])**이
- B에서 메시지 **받은 사건([2,1])**보다 확실히 앞선다.

```sql
A send: [2,0] → B recv: [2,1] → 선후 관계 확실
```

이렇게 벡터 시계는

그냥 숫자 줄 세우기가 아니라

**사건이 실제로 연결되어 있는지(선후 관계가 성립하는지)** 를 더 또렷하게 보여준다.



## **마무리**

- **램포트 시계**
    - 분산 시스템에서 모든 이벤트들에 상대적인 **논리적 순서**를 붙이는 좋은 방법이지만,
        
        숫자 한 개만으로는 독립 사건까지 구분하기 어렵다.
        
- **벡터 시계**
    - 서버별로 어디까지 반영했는지 벡터로 들고 다녀서,
        
        두 사건이 **선후 관계인지, 독립 사건인지**를 더 정확히 구분할 수 있게 해준다.