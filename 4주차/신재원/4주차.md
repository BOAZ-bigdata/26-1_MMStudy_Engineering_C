CockroachDB

현대의 분산 시스템을 위해 설계된 오픈 소스 분산 SQL 데이터베이스
CockroachDB는 바퀴벌레처럼 견고하고 회복력이 강한 시스템을 목표

고가용성, 자동 복구, 수평 확장을 지원하는 데이터베이스 시스템

Safety가 지켜지는 예시
상황: 리더 장애 + 네트워크 분리

<img width="1342" height="916" alt="image" src="https://github.com/user-attachments/assets/79364c1b-248b-48f3-88d5-bb59e86e53e5" />


노드 5개 (A,B,C,D,E)

A가 리더였는데 갑자기 죽으면?

CockroachDB는 이중화를 위해 Raft 분산 합의 알고리즘을 사용.

각 Range들은 replica 단위이고 Default로 3개의 replica를 구성한다. (환경설정으로 변경 가능)

node 추가 삭제 시  자동으로 replica를 rebalancing 하게 된.

<img width="1356" height="1041" alt="image" src="https://github.com/user-attachments/assets/86c614a2-ccc5-412e-87c5-55e09439c066" />

Raft의 Safety 규칙

새 리더는 반드시 과반수(3개 이상) 의 투표를 받아야 함

commit은 반드시 과반수에 로그가 복제된 후 확정

두 개의 리더가 동시에 commit하는 split-brain을 원천 차단
= Safety

<img width="1352" height="1011" alt="image" src="https://github.com/user-attachments/assets/daa7bb53-0197-4439-96a9-9a664b0746e8" />

1) Safety 예시 (Rebalancing 중에도 데이터가 안 깨지는 이유)
✅ 예시 1:

상황  : Range R이 Node1, Node2, Node3에 replica 3개 있음

Node4가 추가됨 → DB가 rebalancing 시작 - 부하/용량/장애 내성/지역 분산”을 최적화

목표: x = 10 쓴 뒤, x = 20 쓰기 

문제 : 네트워크 분리(Partition)가 생겨서 Node1,2는 아직 C_old를 믿음 , Node3,4는 이미 C_new를 믿음


기존: (1,2,3) -> 변경: (1,2,4)  -> Config_old = {1,2,3} , Config_new = {1,2,4}

(1,2,3)에서

(1,2,3,4)로 잠깐 같이 두고

다시 (1,2,4)로 정리

x=10 / x=20 이 모든 노드로 들어가지 않음 

Node1,2는 x=10이 commit된 세계

Node3,4는 x=20이 commit된 세계

 
서로 다른 commit이 발생할 가능성이 생김 .

- 근데 Safety는 어떻게 지켜지냐?

Raft는 “구성 변경”을 아무렇게나 하지 않고

joint consensus(공동 합의) 방식으로 membership을 바꿈, 과반수(majority)가 commit을 결정


 
서로 다른 commit이 발생할 가능성이 안 생김 .

